#!/bin/bash

set -e

preparation() {
   if [ ! "$temp_dir" = "" ]; then
      true "INFO: custom temp_dir"
      return 0
   fi
   temp_dir="$(mktemp --directory)"
   mkdir -p "$temp_dir/keys"
}

no_ssh_found_exit() {
   $output_command "ERROR: ssh client not installed" >&2
   $output_command ""
   $output_command "INFO: To install:"
   $output_command ""
   $output_command "sudo apt update"
   $output_command "sudo apt install --no-install-recommends openssh-client"
   $output_command ""
   $output_command "ERROR: Stop." >&2
   exit 101
}

if test -o xtrace ; then
   output_command=true
else
   output_command=echo
fi

if test -d ~/.ssh ; then
   $output_command "ERROR: Folder ~/.ssh already exists" >&2
   $output_command ""
   $output_command "INFO: Highly recommended to update your ~/.ssh folder!"
   $output_command ""
   $output_command "INFO: To move the existing ~/.ssh folder out of the way:"
   $output_command "INFO: mv ~/.ssh ~/.ssh_my_backup"
   $output_command ""
   $output_command "ERROR: Stop." >&2
   exit 100
fi

if test -h /usr/bin/ssh ; then
   ## Whonix
   if ! command -v /usr/bin/ssh.anondist-orig &>/dev/null ; then
      no_ssh_found_exit
   fi
else
   ## Non-Whonix or no uwt installed.
   if ! command -v ssh &>/dev/null ; then
      no_ssh_found_exit
   fi
fi

my_vm_name="$(qubesdb-read /name)"

preparation
cd "$temp_dir"
mkdir -p "$temp_dir/qubes-remote-support"

## input wormhole code and press enter
## to confirm, press y and press enter
wormhole receive
## Example output including user interaction:
# Enter receive wormhole code: 8-reproduce-virus
#  (note: you can use <Tab> to complete words)
# Waiting for sender...
# Receiving file (817 Bytes) into: remote-support-keys.tar.gz
# ok? (y/N): y
# Receiving (->relay:tcp:magic-wormhole-transit.debian.net:4001)..
# 100%|| 817/817 [00:00<00:00, 2.49MB/s]
# Received file written to remote-support-keys.tar.gz

## As seen in output above, wormhole points out the file size beforehand.

## Debugging.
if test -o xtrace ; then
   ls -la
   ls -la remote-support-keys.tar.gz
fi

file_size="$(stat --printf="%s" remote-support-keys.tar.gz)"
## example output:
## 818

if [ "$file_size" -ge 1000 ]; then
   $output_command "ERROR: file_size of $temp_dir/qubes-remote-support/remote-support-keys.tar.gz larger than 1000. file_size: $file_size"
   exit 102
fi

tar --warning=no-timestamp -xvf remote-support-keys.tar.gz -C "$temp_dir/qubes-remote-support"

## Debugging.
if test -o xtrace ; then
   ls -la
   ls -la "$temp_dir/qubes-remote-support/keys"
fi

## TODO: sanitize
hostname="$(cat "$temp_dir/qubes-remote-support/keys/hostname")"
## Example hostname:
## pp3nxkdbekhaac6r57blbrgniramltvriuukw6g6vqpbudymk33mpnyd.onion

## Rely on ssh for sanitation.
ssh_algorithm="$(cat "$temp_dir/qubes-remote-support/keys/ssh_algorithm")"
## Example ssh_algorithm:
## ssh-ed25519

## Rely on ssh for sanitation.
ssh_fingerprint="$(cat "$temp_dir/qubes-remote-support/keys/ssh_fingerprint")"
## Example ssh_fingerprint:
## AAAAC3NzaC1lZDI1NTE5AAAAICF7BLyxUHVzpwD9DVcG5+H+1TydgvcQlTQdKrXqNgFF

ssh_known_keys_line="$hostname $ssh_algorithm $ssh_fingerprint"

mkdir -p ~/.ssh
## Rely on ssh for sanitation of id_ed25519.pub.
cp "$temp_dir/qubes-remote-support/keys/id_ed25519.pub" ~/.ssh/
## Rely on ssh for sanitation of id_ed25519.
cp "$temp_dir/qubes-remote-support/keys/id_ed25519" ~/.ssh/
echo "$ssh_known_keys_line" > ~/.ssh/known_hosts
chmod 700 ~/.ssh
chmod 600 ~/.ssh/*

## example id_ed25519:
## -----BEGIN OPENSSH PRIVATE KEY-----
## b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
## QyNTUxOQAAACAEJ82o4Knq4gSJAr0Mke+5y2fdl6vo8v+dBlz5bKfSyQAAALDJ/1Ulyf9V
## JQAAAAtzc2gtZWQyNTUxOQAAACAEJ82o4Knq4gSJAr0Mke+5y2fdl6vo8v+dBlz5bKfSyQ
## AAAEBFm5blNb/E4K9WL6NhqyffoPrbuwtiGkCs0hOyHsb4cAQnzajgqeriBIkCvQyR77nL
## Z92Xq+jy/50GXPlsp9LJAAAALHF1YmVzLXJlbW90ZS1zdXBwb3J0LXJlY2VpdmVyLWF1dG
## 8tZ2VuZXJhdGVkAQ==
## -----END OPENSSH PRIVATE KEY-----

## example id_ed25519.pub:
#ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAQnzajgqeriBIkCvQyR77nLZ92Xq+jy/50GXPlsp9LJ qubes-remote-support-receiver-auto-generated

$output_command "INFO: Press enter to continue"
$output_command ""

$output_command "INFO: To avoid confusion, it is advised your delete folder ~/QubesIncoming in sys-whonix if it exists. In most cases no such folder exists."
$output_command "INFO: If there is nothing you need to backup, you could run the following command."
$output_command "rm -rf ~/QubesIncoming"
read press_enter_to_continue

$output_command "INFO: Will ask to copy 1.auth_private to sys-whonix."
$output_command "INFO: In other words, will run the following command:"
$output_command "qvm-copy $temp_dir/qubes-remote-support/keys/1.auth_private"
$output_command "INFO: When Qubes dom0 asks, answer to copy to sys-whonix."
read press_enter_to_continue

## Example 1.auth_private contents:
## pp3nxkdbekhaac6r57blbrgniramltvriuukw6g6vqpbudymk33mpnyd:descriptor:x25519:CC2Z373LXU36QEKG5JIFCFMUDOYB73U26MZ6FAQDGLOWYQAGWBBA

## TODO: qvm-copy and a dom0 prompt is not very convenient.
##       Is there any elegant way to automate that?
##
## Rely on Tor for sanitation of 1.auth_private.
qvm-copy "$temp_dir/qubes-remote-support/keys/1.auth_private"

$output_command ""
$output_command "INFO: Install authenticated Tor onion v3 service private key with the following command in sys-whonix."
$output_command "sudo sourcefile=~/QubesIncoming/${my_vm_name}/1.auth_private anon-server-to-client-install"

read press_enter_to_continue

$output_command ""
$output_command "INFO: Do you want to SSH to '$hostname'?"
read press_enter_to_continue

$output_command ""
$output_command "INFO: Trying SSH..."

counter=0

## Required 13 retries during testing until onion v3 service was ready.
## Took 3:30 minutes.
## Another attempt:
## Required 33 retries during testing until onion v3 service was ready.
## Took 5:30 minutes.
while true ; do
   counter="$((counter + 1))"
   if [ "$counter" -ge "500" ]; then
      $output_command "ERROR: SSH connection unsuccessful!"
      exit 1
   fi
   if ssh "$hostname" ; then
      true "INFO: SSH success."
   else
      sleep 10
   fi
done
